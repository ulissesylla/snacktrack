<task>
  <submodule>4.4: Cálculos e Agregações</submodule>
  <objective>
    Implementar cálculos complexos e agregações para o dashboard, reutilizando e estendendo os serviços existentes.
    - Calcular consumo médio diário por produto e local
    - Implementar estatísticas avançadas para o dashboard
    - Reutilizar estoqueService para consistência nos cálculos
    - Considerar local_id em todos os cálculos agregados
    - Otimizar performance com cache e consultas eficientes
  </objective>

  <files>
    <!-- EXPANSÃO DO SERVIÇO DE DASHBOARD -->
    <file type="backend">
      <path>services/dashboardService.js</path>
      <purpose>Expandir serviço com cálculos complexos e agregações</purpose>
      <requirements>
        - calcularConsumoMedio: método para calcular consumo médio diário por produto e local
        - getEstatisticasAvancadas: expandir estatísticas com dados agregados
        - getProdutosMaisMovimentados: identificar produtos com maior movimento
        - getLocaisComMaiorMovimentacao: ranking de locais por movimento
        - REUTILIZAR estoqueService.getEstoqueAtual() para cálculos consistentes
        - CONSIDERAR local_id em todos os cálculos agregados
        - ~~IMPLEMENTAR cache para cálculos pesados (1 hora)~~ REMOVER ESTA LINHA
        - EVITAR duplicação de lógica já existente em outros serviços
      </requirements>
    </file>

    <!-- CAMADA DE DADOS PARA AGREGAÇÕES -->
    <file type="backend">
      <path>data/dashboardData.js</path>
      <purpose>Camada de dados especializada em consultas de agregação</purpose>
      <requirements>
        - calcularConsumoMedioProduto: SQL para consumo médio por produto e local
        - getEstatisticasMovimentacaoPorPeriodo: agregar movimentações por período
        - getTopProdutosMovimentacao: ranking de produtos por quantidade movimentada
        - getMovimentacaoPorLocal: agregar movimentações por local
        - CONSULTAS OTIMIZADAS com índices apropriados
        - USAR SUM, AVG, COUNT com GROUP BY para agregações
        - FILTRAR por datas e locais específicos quando aplicável
      </requirements>
    </file>

    <!-- ATUALIZAÇÃO DO CONTROLADOR DO DASHBOARD -->
    <file type="backend">
      <path>controllers/dashboardController.js</path>
      <purpose>Adicionar endpoints para cálculos avançados</purpose>
      <requirements>
        - getConsumoMedio: novo endpoint para consumo médio de produtos
        - getEstatisticasAvancadas: expandir endpoint existente com mais dados
        - getRankings: endpoint para produtos e locais mais movimentados
        - PARÂMETROS OPCIONAIS: local_id, periodo_dias, limite
        - REUTILIZAR validações e padrões de response existentes
        - INTEGRAR com serviços atualizados do dashboardService
      </requirements>
    </file>

    <!-- ATUALIZAÇÃO DAS ROTAS DO DASHBOARD -->
    <file type="backend">
      <path>routes/dashboardRoutes.js</path>
      <purpose>Adicionar endpoints para cálculos avançados</purpose>
      <requirements>
        - GET /api/dashboard/consumo-medio - Novo endpoint para consumo médio
        - GET /api/dashboard/estatisticas-avancadas - Expandir endpoint existente
        - GET /api/dashboard/rankings - Endpoint para rankings
        - MANTER endpoints básicos existentes inalterados
        - APLICAR middleware requireAuth em todos os endpoints
      </requirements>
    </file>
  </files>

  <integration_lessons>
    <lesson from="4.2">
      <principle>Reutilizar estoqueService para cálculos consistentes</principle>
      <application>Usar estoqueService.getEstoqueAtual() em vez de cálculos manuais</application>
    </lesson>
    <lesson from="4.2">
      <principle>Considerar local_id em cálculos agregados</principle>
      <application>Todos os cálculos devem suportar filtro por local específico</application>
    </lesson>
    <lesson from="4.2">
      <principle>Evitar duplicação e processamento desnecessário</principle>
      <application>otimizar consultas sql e reutilizar serviços existentes</application>
    </lesson>
  </integration_lessons>

  <calculation_specifications>
    <calculation>
      <name>Consumo Médio Diário</name>
      <formula>(Total de saídas dos últimos 30 dias) / 30</formula>
      <parameters>
        - produto_id: obrigatório
        - local_id: opcional (se não informado, calcular para todos os locais)
        - periodo_dias: opcional (padrão: 30)
      </parameters>
      <logic>
        - Filtrar movimentações do tipo 'Saída' e 'Transferência' (quando local é origem)
        - Considerar apenas últimos N dias (padrão: 30)
        - Agrupar por produto_id e local_id
        - Calcular: SUM(quantidade) / periodo_dias
      </logic>
    </calculation>

    <calculation>
      <name>Estatísticas Avançadas</name>
      <metrics>
        - total_entradas_30dias: soma de entradas últimos 30 dias
        - total_saidas_30dias: soma de saídas últimos 30 dias  
        - total_transferencias_30dias: soma de transferências últimos 30 dias
        - produtos_estoque_baixo: contagem de produtos com estoque abaixo do mínimo
        - produtos_validade_proxima: contagem de produtos com validade próxima
      </metrics>
    </calculation>
  </calculation_specifications>

  <api_endpoints>
    <endpoint>
      <method>GET</method>
      <path>/api/dashboard/consumo-medio</path>
      <query_params>?produto_id=5&local_id=1&periodo_dias=30</query_params>
      <response>
        {
          "success": true,
          "consumo_medio": [
            {
              "produto_id": 5,
              "produto_nome": "Farinha de Trigo",
              "local_id": 1,
              "local_nome": "Loja Principal",
              "consumo_medio_diario": 8.5,
              "periodo_dias": 30,
              "total_saidas_periodo": 255
            }
          ]
        }
      </response>
    </endpoint>

    <endpoint>
      <method>GET</method>
      <path>/api/dashboard/estatisticas-avancadas</path>
      <response>
        {
          "success": true,
          "estatisticas": {
            "movimentacao_30dias": {
              "total_entradas": 450,
              "total_saidas": 380,
              "total_transferencias": 120
            },
            "alertas_ativos": {
              "estoque_baixo": 5,
              "validade_proxima": 3
            },
            "produtos_mais_movimentados": [...]
          }
        }
      </response>
    </endpoint>
  </api_endpoints>

  <performance_considerations>
  <strategy>Otimização via índices e consultas SQL eficientes</strategy>
  <approach>
    - Focar em consultas SQL bem otimizadas com índices apropriados
    - Usar aggregates nativos do MySQL (SUM, AVG, COUNT) 
    - Aplicar filtros por data para reduzir volume de dados processados
    - Considerar implementação de cache futuro apenas se performance for problema
  </approach>
  <implementation>
    - Monitorar performance com dados reais após implementação
    - Priorizar correção dos cálculos sobre otimização prematura
    - Manter código simples e legível para fácil manutenção
  </implementation>
</performance_considerations>

  <sql_optimization>
    <indexes>
      - movimentacoes: data_movimentacao, tipo, produto_id, local_origem_id, local_destino_id
      - produtos: estoque_minimo, data_validade
    </indexes>
    <techniques>
      - Usar BETWEEN para filtros de data
      - Usar INDEX para campos frequentemente filtrados
      - Evitar subqueries desnecessárias
      - Usar LIMIT em consultas de ranking
    </techniques>
  </sql_optimization>

  <dependencies>
    - Sub-módulo 4.1 implementado (endpoints básicos)
    - Sub-módulo 4.2 implementado (sistema de alertas)
    - Sub-módulo 4.3 implementado (consultas complexas)
    - estoqueService disponível e testado
  </dependencies>

  <testing_focus>
  - Consumo médio: cálculo correto baseado em saídas dos últimos 30 dias
  - Estatísticas avançadas: dados agregados corretos por período
  - ~~Cache: funcionamento correto e invalidação apropriada~~ REMOVER
  - Performance: tempos de resposta aceitáveis com otimizações SQL
  - Local_id: cálculos específicos por local funcionando corretamente
</testing_focus>

  <integration_notes>
    - Estes cálculos serão usados pelo Sub-módulo 4.6 (Dashboard Frontend)
    - Consumo médio será exibido na tabela de estoque do dashboard
    - Estatísticas avançadas alimentarão os cards do dashboard
    - Rankings poderão ser usados para relatórios futuros
  </integration_notes>
</task>