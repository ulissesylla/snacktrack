<task>
  <submodule>3.1: Serviço Central de Estoque</submodule>
  <objective>
    Implementar o núcleo do sistema de movimentações de estoque com transações SQL e validações críticas.
    - Criar estoqueService.js com métodos principais para entrada, saída e transferência
    - Implementar camada de dados para movimentações
    - Garantir consistência com transações SQL
    - Validar regras de negócio críticas
  </objective>

  <files>
    <!-- SERVIÇO PRINCIPAL DE ESTOQUE -->
    <file type="backend">
      <path>services/estoqueService.js</path>
      <purpose>Serviço central com lógica de movimentações e transações</purpose>
      <requirements>
        - Classe EstoqueService com métodos:
          * registrarEntrada(produtoId, localId, quantidade, usuarioId)
          * registrarSaida(produtoId, localId, quantidade, usuarioId) 
          * transferir(produtoId, localOrigemId, localDestinoId, quantidade, usuarioId)
        - Usar transações SQL para garantir atomicidade
        - Validações críticas:
          * registrarSaida: verificar se há estoque suficiente
          * transferir: verificar estoque na origem E validar destino
        - Lançar erros específicos para cada tipo de falha
        - Registrar movimentações na tabela movimentacoes
        - Retornar resultado da operação com detalhes
      </requirements>
    </file>

    <!-- CAMADA DE DADOS PARA MOVIMENTAÇÕES -->
    <file type="backend">
      <path>data/movimentacaoData.js</path>
      <purpose>Camada de acesso a dados para operações de movimentação</purpose>
      <requirements>
        - create(movimentacaoData): inserir nova movimentação
        - getEstoqueAtual(produtoId, localId): calcular estoque atual via SQL
        - getMovimentacoesByProduto(produtoId): buscar histórico por produto
        - getMovimentacoesByLocal(localId): buscar histórico por local
        - Usar conexão singleton do database.js
        - Suportar transações (receber connection como parâmetro opcional)
      </requirements>
    </file>

    <!-- ATUALIZAÇÃO DA CONEXÃO COM BANCO -->
    <file type="backend">
      <path>config/database.js</path>
      <purpose>Adicionar suporte a transações na conexão singleton</purpose>
      <requirements>
        - Manter padrão singleton existente
        - Adicionar métodos para transações:
          * beginTransaction()
          * commit(connection)
          * rollback(connection)
        - Garantir que pool de conexões suporte transações
      </requirements>
    </file>

    <!-- MODELO DE DADOS PARA MOVIMENTAÇÕES -->
    <file type="backend">
      <path>models/Movimentacao.js</path>
      <purpose>Modelo de dados para representar movimentações (opcional, mas recomendado)</purpose>
      <requirements>
        - Classe Movimentacao com propriedades:
          * id, tipo, produto_id, local_origem_id, local_destino_id
          * quantidade, usuario_id, data_movimentacao
        - Métodos para validação de dados
        - Conversores para JSON e formato de banco
      </requirements>
    </file>
  </files>

  <business_rules>
    <rule>
      <name>Validação de Saída</name>
      <description>Impedir saída se quantidade solicitada > estoque disponível</description>
      <logic>
        estoque_atual = SUM(entradas) - SUM(saídas) - SUM(transferências_saída) + SUM(transferências_entrada)
        IF quantidade_saída > estoque_atual THEN lançar erro "Estoque insuficiente"
      </logic>
    </rule>

    <rule>
      <name>Validação de Transferência</name>
      <description>Verificar origem tem estoque e destino é válido</description>
      <logic>
        IF local_origem_id = local_destino_id THEN lançar erro "Locais iguais"
        IF estoque_origem < quantidade THEN lançar erro "Estoque insuficiente na origem"
        IF local_destino_id não existe THEN lançar erro "Local destino inválido"
      </logic>
    </rule>
  </business_rules>

  <transaction_flow>
    <operation>registrarSaida</operation>
    <steps>
      1. BEGIN TRANSACTION
      2. SELECT estoque_atual FOR UPDATE (trava o registro)
      3. IF estoque_atual >= quantidade THEN
      4.   INSERT movimentacao (tipo='Saída', ...)
      5.   COMMIT
      6. ELSE
      7.   ROLLBACK
      8.   THROW ErroEstoqueInsuficiente
    </steps>
  </transaction_flow>

  <error_types>
    <error>
      <name>ErroEstoqueInsuficiente</name>
      <code>ESTOQUE_INSUFICIENTE</code>
      <message>Estoque insuficiente para realizar a operação</message>
      <http_status>422</http_status>
    </error>

    <error>
      <name>ErroLocalInvalido</name>
      <code>LOCAL_INVALIDO</code> 
      <message>Local de origem ou destino inválido</message>
      <http_status>400</http_status>
    </error>

    <error>
      <name>ErroProdutoInvalido</name>
      <code>PRODUTO_INVALIDO</code>
      <message>Produto não encontrado ou inativo</message>
      <http_status>400</http_status>
    </error>
  </error_types>

  <database_considerations>
    - Tabela movimentacoes já existe (criada no Módulo 0)
    - Não precisa de tabela de estoque_atual - calcular via SQL dinamicamente
    - Usar SUM() com GROUP BY para calcular estoque atual
    - Índices em produto_id e local_id para performance
  </database_considerations>

  <sql_calculo_estoque>
    -- Cálculo de estoque atual para um produto em um local
    SELECT 
      COALESCE(
        SUM(CASE 
          WHEN tipo = 'Entrada' AND local_destino_id = ? THEN quantidade
          WHEN tipo = 'Saída' AND local_origem_id = ? THEN -quantidade
          WHEN tipo = 'Transferência' AND local_origem_id = ? THEN -quantidade
          WHEN tipo = 'Transferência' AND local_destino_id = ? THEN quantidade
        END), 0
      ) as estoque_atual
    FROM movimentacoes 
    WHERE produto_id = ?
  </sql_calculo_estoque>

  <dependencies>
    - Módulo 2 completo (produtos e locais cadastrados)
    - Tabela movimentacoes criada no Módulo 0
    - Sistema de autenticação do Módulo 1
  </dependencies>

  <testing_focus>
    - Testar cenários de concorrência com transações
    - Validar cálculos de estoque em operações simultâneas
    - Verificar rollback em caso de erro
    - Testar todos os tipos de erro específicos
  </testing_focus>

  <implementation_notes>
    - Focar na robustez do serviço central
    - Transações são críticas para evitar inconsistências
    - Cálculo de estoque via SQL é mais confiável que em memória
    - Logs detalhados para debugging de operações complexas
  </implementation_notes>
</task>