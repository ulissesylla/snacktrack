<task>
  <submodule>3.2: API de Movimentações</submodule>
  <objective>
    Criar endpoints RESTful para todas as operações de movimentação de estoque.
    - Implementar rotas para entrada, saída e transferência
    - Criar controladores com validações de entrada
    - Integrar com o estoqueService do Sub-módulo 3.1
    - Tratar erros específicos do domínio de estoque
  </objective>

  <files>
    <!-- ROTAS PARA MOVIMENTAÇÕES -->
    <file type="backend">
      <path>routes/movimentacaoRoutes.js</path>
      <purpose>Definir todas as rotas de movimentação com middleware de autenticação</purpose>
      <requirements>
        - POST /api/movimentacoes/entrada - Registrar entrada de estoque
        - POST /api/movimentacoes/saida - Registrar saída de estoque  
        - POST /api/movimentacoes/transferencia - Registrar transferência
        - GET /api/movimentacoes/historico - Listar histórico de movimentações (opcional, básico)
        - Aplicar middleware requireAuth em todas as rotas
        - Não restringir por função (todos usuários autenticados podem usar)
        - Usar controladores do movimentacaoController
      </requirements>
    </file>

    <!-- CONTROLADOR DE MOVIMENTAÇÕES -->
    <file type="backend">
      <path>controllers/movimentacaoController.js</path>
      <purpose>Controlador para processar requisições de movimentação</purpose>
      <requirements>
        - registrarEntrada: valida dados e chama estoqueService.registrarEntrada()
        - registrarSaida: valida dados e chama estoqueService.registrarSaida()
        - registrarTransferencia: valida dados e chama estoqueService.transferir()
        - listarHistorico: retorna histórico básico de movimentações
        - Validações de entrada:
          * produto_id: obrigatório, deve existir
          * local_id: obrigatório, deve existir (para entrada/saída)
          * local_origem_id, local_destino_id: obrigatórios para transferência
          * quantidade: obrigatória, número positivo
        - Extrair usuario_id do req.session.user
        - Tratar erros específicos do estoqueService e retornar HTTP status apropriados
      </requirements>
    </file>

    <!-- MIDDLEWARE DE VALIDAÇÃO ESPECÍFICO -->
    <file type="backend">
      <path>middleware/validacaoMovimentacao.js</path>
      <purpose>Middleware para validar dados de movimentação</purpose>
      <requirements>
        - validarEntrada: verifica produto_id, local_id, quantidade
        - validarSaida: verifica produto_id, local_id, quantidade  
        - validarTransferencia: verifica produto_id, local_origem_id, local_destino_id, quantidade
        - Verificar se IDs existem no banco (produtos, locais)
        - Verificar se quantidade é número positivo
        - Retornar 400 com mensagens de erro específicas
      </requirements>
    </file>

    <!-- ATUALIZAÇÃO DO SERVIDOR PRINCIPAL -->
    <file type="backend">
      <path>server.js</path>
      <purpose>Registrar rotas de movimentação no servidor</purpose>
      <requirements>
        - Importar e usar movimentacaoRoutes
        - Garantir que as rotas sejam adicionadas após o middleware de sessions
      </requirements>
    </file>
  </files>

  <api_endpoints>
    <endpoint>
      <method>POST</method>
      <path>/api/movimentacoes/entrada</path>
      <body>
        {
          "produto_id": "number (obrigatório)",
          "local_id": "number (obrigatório)", 
          "quantidade": "number (obrigatório, positivo)"
        }
      </body>
      <response>
        - 201: { "success": true, "movimentacao": { ... } }
        - 400: { "error": "Dados inválidos", "details": [...] }
        - 422: { "error": "ErroEstoqueInsuficiente", "message": "..." }
      </response>
    </endpoint>

    <endpoint>
      <method>POST</method>
      <path>/api/movimentacoes/saida</path>
      <body>
        {
          "produto_id": "number (obrigatório)",
          "local_id": "number (obrigatório)",
          "quantidade": "number (obrigatório, positivo)" 
        }
      </body>
      <response>
        - 201: { "success": true, "movimentacao": { ... } }
        - 400: { "error": "Dados inválidos", "details": [...] }
        - 422: { "error": "ESTOQUE_INSUFICIENTE", "message": "Estoque insuficiente" }
      </response>
    </endpoint>

    <endpoint>
      <method>POST</method>
      <path>/api/movimentacoes/transferencia</path>
      <body>
        {
          "produto_id": "number (obrigatório)",
          "local_origem_id": "number (obrigatório)",
          "local_destino_id": "number (obrigatório)", 
          "quantidade": "number (obrigatório, positivo)"
        }
      </body>
      <response>
        - 201: { "success": true, "movimentacao": { ... } }
        - 400: { "error": "Dados inválidos", "details": [...] }
        - 422: { "error": "ESTOQUE_INSUFICIENTE", "message": "Estoque insuficiente na origem" }
      </response>
    </endpoint>

    <endpoint>
      <method>GET</method>
      <path>/api/movimentacoes/historico</path>
      <query_params>
        ?produto_id=1&local_id=2&limit=50
      </query_params>
      <response>
        - 200: { "movimentacoes": [...], "total": 100 }
      </response>
    </endpoint>
  </api_endpoints>

  <validation_rules>
    <rule>
      <field>produto_id</field>
      <required>true</required>
      <type>number</type>
      <validation>Deve existir na tabela produtos e estar ativo</validation>
    </rule>

    <rule>
      <field>local_id</field>
      <required>true (para entrada/saída)</required>
      <type>number</type>
      <validation>Deve existir na tabela locais e estar ativo</validation>
    </rule>

    <rule>
      <field>quantidade</field>
      <required>true</required>
      <type>number</type>
      <validation>Maior que 0, número válido</validation>
    </rule>

    <rule>
      <field>local_origem_id, local_destino_id</field>
      <required>true (para transferência)</required>
      <type>number</type>
      <validation>Devem existir e ser diferentes</validation>
    </rule>
  </validation_rules>

  <error_handling>
    <error>
      <type>ValidationError</type>
      <status>400</status>
      <response>
        {
          "error": "Dados inválidos",
          "details": [
            { "field": "produto_id", "message": "Produto é obrigatório" },
            { "field": "quantidade", "message": "Quantidade deve ser positiva" }
          ]
        }
      </response>
    </error>

    <error>
      <type>ESTOQUE_INSUFICIENTE</type>
      <status>422</status>
      <response>
        {
          "error": "ESTOQUE_INSUFICIENTE",
          "message": "Estoque insuficiente para realizar a operação",
          "estoque_atual": 50,
          "quantidade_solicitada": 100
        }
      </response>
    </error>

    <error>
      <type>LOCAL_INVALIDO</type>
      <status>400</status>
      <response>
        {
          "error": "LOCAL_INVALIDO", 
          "message": "Local de origem ou destino inválido"
        }
      </response>
    </error>
  </error_handling>

  <authentication_integration>
    - Todas as rotas protegidas por requireAuth
    - usuario_id extraído de req.session.user.id
    - Não há restrição por função (todos usuários autenticados podem usar)
    - Log de qual usuário realizou cada movimentação
  </authentication_integration>

  <dependencies>
    - Sub-módulo 3.1 completamente implementado (estoqueService)
    - Módulo 1 (autenticação e sessions)
    - Módulo 2 (produtos e locais cadastrados)
  </dependencies>

  <testing_scenarios>
    1. **Entrada válida** → 201 com dados da movimentação
    2. **Entrada com produto inexistente** → 400
    3. **Saída com estoque suficiente** → 201
    4. **Saída com estoque insuficiente** → 422
    5. **Transferência válida** → 201
    6. **Transferência com locais iguais** → 400
    7. **Sem autenticação** → 401
    8. **Quantidade zero ou negativa** → 400
  </testing_scenarios>

  <implementation_notes>
    - Usar async/await em todos os controladores
    - Aplicar validação antes de chamar estoqueService
    - Logar movimentações para auditoria
    - Manter consistência com padrões de resposta da API existente
    - Extrair usuario_id da session, não do body (segurança)
  </implementation_notes>
</task>